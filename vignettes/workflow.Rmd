---
title: "Typical DPR2 Workflow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Typical DPR2 Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

# Temporary working directory for example data package

twd <- tempfile('vpkg')
dir.create(twd)
knitr::opts_knit$set(root.dir = twd)
```

This vignette demonstrates the DPR2 workflow for building data packages. We will go over key DPR2 functions and how to build a data package from start to finish.

# DPR2 workflow overview

1. Create a folder with the name of the new data package.
2. Start an R session with that folder set as the working directory.
3. Load the DPR2 library with `library(DPR2)`
4. Initialize the data data package with `dpr_init()`
5. Add any nessessary source data to the folder `inst/extdata`
6. Add your processing scripts to the folder `processing`
7. Build the data package with `dpr_build()`

In this workflow, processing script are written to transform source data into analysis data. Static vignettes and documentation are rendered from those script and any data that is generated can be saved to the package use `dpr_save()`.

## The DPR2 YAML and API

DPR2 was designed so that any package building behavior configurations can be stored in a package's `datapackager.yml` file that lives at the data package source's root directory. This file is generated when the data package is initialized and is maintained by the user. The DPR2 API is designed around this concept, much like the original DataPackageR, however DPR2 also allows for changing the values in that file in an adhoc fashion by using the ellipsis operator in all its function calls that access the values in the configuration yaml file. 

## Initializing a DPR2 package

```{r}
library(DPR2)
dpr_init()
```

There are two ways one can initialize a new DPR2 package: using `dpr_init` or `dpr_create`. `dpr_init` is simply a wrapper of `dpr_create`, where `dpr_init` will create a new DPR2 package at the current working directory, and `dpr_create` will create a new DPR2 package at a specified path. When the package is initialized, DPR2 will check if any nessessary files it needs are already present and create those if they are missing. This functionality is handy when a package already exists and a user would like to maintain that package using DPR2.

By default, DPR2 is initialized using renv for dependancy version control. DPR2 can help tackle problems of unstable and non-reproducible environments by setting `renv_init = TRUE` when initializing a DPR2 package. Once the data package is initialized with renv, renv will make sure once a dependency is installed by a user, it will use the same version of that dependency when building the data package in the future, and will inform users whether they need to install a particular version of a package dependency. For more details on `renv`, refer to the [renv documentation](https://docs.posit.co/ide/user/ide/guide/environments/r/renv.html).

## Building a DPR2 package

Before a package is built, a processing script must be added to the `processing` directory.

```{r add-processing-script, echo = FALSE}
writeLines(
    c(
      "---",
      "title: example processing script",
      "---",
      "Example text",
      "",
      "```{r}",
      "library(DPR2)",
      "my_df <- data.frame(a = 1:5, b = letters[1:5])",
      "dpr_save('my_df')",
      "```"
    ),
    dpr_path("processing", "my_process.Rmd")
  )
```

### Adding an example processing script

```{r view-processing-script}
cat(
  readLines(
    dpr_path('processing', 'my_process.Rmd')
  ), sep = '\n'
)
```

`dpr_path()` is used to refer to other paths within processing scripts and `dpr_save()` to save objects to the `data` directory. Objects are saved this way are saved as `rda` files. DPR2 requires all data objects be saved as single object RDA files.

DPR2 maintains the DataPackageR functions `project_path`,`project_data_path` and `project_extdata_path` to ensure compatibility with scripts written for DataPackageR, but they are not recommended to use for new scripts as these funcutions may be removed from future versions of DPR2.

### dpr_build and dpr_render

`dpr_build` and `dpr_render` are the function used for building a data package from processing scripts. `dpr_build` wraps `dpr_render` but in addition may do the following:

* save the rendered processing scripts to vignettes in the data package source
* update the data digest with new checksums
* build the package tarball 
* install the package in the current R environment

`dpr_render` can be used before `dpr_build` if the user doesn't immediately want to build the package, but instead is interested if the package can be built successfully or if the associated vignettes are rendered correctly.

```{r render}
dpr_render(process_on_build = 'my_process.Rmd')
```

In the above example, this call to `dpr_render` makes use of the ellipsis operator, temporarily overriding the value for `process_on_build` in the `datapackager.yml` file.

### Build the data package

After checking if `dpr_render` renders the processing scripts without error, `dpr_build` can be used to build and install the package. Users also can choose to skip rendering and build the package as is.

```{r build}
dpr_build()

# examine data directory
list.files("data")
```

### Examine the data digest

As mentioned in \link{introduction}, the data digest is formatted as a directory of files. Each of these files contains the md5 checksum of the objects loaded from data in memory. This manner of hashing is consistent with the original DataPackageR. The digest can be viewed at any time as a single file using `DPR2::dpr_data_digest()`

```{r examine-data-digest}
DPR2::dpr_data_digest()
```

### Examine the saved data object

Once a package is built it can be installed and its packaged data and vignettes can be accessed using `data()` and `vignette()` base functions.

```r
data('my_df')
vignette(package="my_data_package")
```
